package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"strconv"
	"testing"
	"time"

	v20250808 "mcpsvc/v20250808"

	si "JeffreyRichter.com/serviceinfra"
	"JeffreyRichter.com/serviceinfra/policies"
)

func TestUsers(t *testing.T) {
	handler := si.BuildHandler([]si.Policy{
		policies.NewLoggingPolicy(os.Stderr),
		policies.NewThrottlingPolicy(10),
	}, []*si.ApiVersionInfo{
		{ApiVersion: "2025-08-08", BaseApiVersion: "", GetRoutes: v20250808.Routes},
	}, time.Minute)

	showBody := func(r *http.Response) {
		defer r.Body.Close()
		j, err := io.ReadAll(r.Body)
		if err != nil {
			log.Printf("Error reading body: %v", err)
			return
		}
		fmt.Printf("Status: %d - ", r.StatusCode)
		fmt.Println(string(j))
	}

	req := httptest.NewRequest(http.MethodGet, "http://localhost:8080/users/Jeffrey?api-version=2021-01-01", nil)
	w := httptest.NewRecorder()
	handler.ServeHTTP(w, req) // Avoid: Doesn't populate Request's PathValue
	showBody(w.Result())

	for _, n := range []string{"Jeffrey", "Kristin", "Aidan", "Grant"} {
		pm := struct {
			Etag         *si.ETag   `json:"etag,omitempty"`
			LastModified *time.Time `json:"last-modified,omitempty" time:"RFC1123"`
			Name         *string    `json:"name,omitempty" minlen:"3" maxlen:"64" regx:"^[a-zA-Z0-9_]+$"`
			Address      *struct {
				Street *string `json:"street,omitempty" minlen:"3" maxlen:"64" regx:"^[a-zA-Z0-9_ ]+$"`
				City   *string `json:"city,omitempty" minlen:"3" maxlen:"64" regx:"^[a-zA-Z0-9_ ]+$"`
				State  *string `json:"state,omitempty" minlen:"2" maxlen:"2" regx:"^[A-Z]{2}$"`
				Zip    *string `json:"zip,omitempty" minlen:"5" maxlen:"10" regx:"^\\d{5}(-\\d{4})?$"`
			} `json:"address,omitempty"`
			Email *string `json:"email,omitempty" minlen:"6" maxlen:"64" regx:"^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})$"`
		}{Name: &n, Email: si.Ptr(n + "@live.com")}
		js, _ := json.Marshal(pm)
		req = httptest.NewRequest(http.MethodPatch, "http://localhost:8080/users/"+n+"?api-version=2021-01-01", bytes.NewReader(js))
		req.Header.Set("Content-Type", "application/merge-patch+json")
		req.Header.Set("Content-Length", strconv.Itoa(len(js)))
		w := httptest.NewRecorder()
		handler.ServeHTTP(w, req) // Avoid: Doesn't populate Request's PathValue
		showBody(w.Result())
	}

	req = httptest.NewRequest("GET", "http://localhost:8080/users/Aidan?api-version=2021-01-01", nil)
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	showBody(w.Result())

	req = httptest.NewRequest("GET", "http://localhost:8080/users?api-version=2022-02-02-preview&skip=1&top=2", nil)
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	showBody(w.Result())

	req = httptest.NewRequest("DELETE", "http://localhost:8080/users/Grant?api-version=2021-01-01", nil)
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	showBody(w.Result())

	req = httptest.NewRequest("GET", "http://localhost:8080/users/Grant?api-version=2021-01-01", nil)
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	showBody(w.Result())

	req = httptest.NewRequest("POST", "http://localhost:8080/users/Jeffrey:sendMail?api-version=2023-03-03", nil)
	w = httptest.NewRecorder()
	handler.ServeHTTP(w, req)
	showBody(w.Result())
}

func TestServer(t *testing.T) {
	go server()
	play()
}

func server() {
	mux := http.NewServeMux()
	mux.Handle("/jeff", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	}))

	mux.HandleFunc("POST /jeff", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "POST jeff")
	})

	mux.HandleFunc("POST /items/create", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "POST item created")
	})

	mux.HandleFunc("/items/create", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "item created")
	})

	mux.HandleFunc("/items/{id}", func(w http.ResponseWriter, r *http.Request) {
		id := r.PathValue("id") // Wildcards in path
		fmt.Fprintf(w, "Item ID = %s", id)
	})

	mux.HandleFunc("/files/{path...}", func(w http.ResponseWriter, r *http.Request) { // ... matches all remaining segments
		path := r.PathValue("path")
		fmt.Fprintf(w, "File path = %s", path)
	})

	mux.HandleFunc("/exact/match/{$}", func(w http.ResponseWriter, r *http.Request) { // {$} matches exact
		fmt.Fprint(w, "exact match")
	})

	mux.HandleFunc("/exact/match/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "prefix match")
	})
	_ = http.ListenAndServe(":8080", mux)
}

func play() {
	server := "http://localhost:8080"
	{
		resp, _ := http.Get(server + "/jeff") // wrong case: Returns 404; No GET=Method Not Allowed
		body, _ := io.ReadAll(resp.Body)
		fmt.Println("GET /Jeff", string(body))
		resp.Body.Close()
	}
	{
		resp, _ := http.Post(server+"/item/creat", "text/plain", nil) // Returns 404
		body, _ := io.ReadAll(resp.Body)
		fmt.Println("POST /items/create:", string(body))
		resp.Body.Close()
	}

	// uses POST route
	resp, _ := http.Post(server+"/items/create", "text/plain", nil)
	body, _ := io.ReadAll(resp.Body)
	fmt.Println("POST /items/create:", string(body))
	resp.Body.Close()

	// uses generic route
	resp, _ = http.Get(server + "/items/create") // HEAD goes to same place
	body, _ = io.ReadAll(resp.Body)
	fmt.Println("GET /items/create:", string(body))
	resp.Body.Close()

	req, _ := http.NewRequest("GET", server+"/items/12345", nil)
	resp, _ = http.DefaultClient.Do(req)
	body, _ = io.ReadAll(resp.Body)
	fmt.Println("GET /items/12345:", string(body))
	resp.Body.Close()

	req, _ = http.NewRequest("GET", server+"/files/a/b/c", nil)
	resp, _ = http.DefaultClient.Do(req)
	body, _ = io.ReadAll(resp.Body)
	fmt.Println("GET /files/a/b/c:", string(body))
	resp.Body.Close()

	// exact match
	req, _ = http.NewRequest("GET", server+"/exact/match/", nil)
	resp, _ = http.DefaultClient.Do(req)
	body, _ = io.ReadAll(resp.Body)
	fmt.Println("GET /exact/match/:", string(body))
	resp.Body.Close()

	// prefix match
	req, _ = http.NewRequest("GET", server+"/exact/match/123", nil)
	resp, _ = http.DefaultClient.Do(req)
	body, _ = io.ReadAll(resp.Body)
	fmt.Println("GET /exact/match/123:", string(body))
	resp.Body.Close()
}
